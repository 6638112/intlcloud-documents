## 동일 원본 서버 정책
동일 원본 서버 정책은 하나의 서버에서 로딩된 문서 또는 스크립트가 또 다른 서버의 리소스와 상호작용하는 것을 제한하는 방식으로, 잠재적인 악성 파일을 차단하기 위한 핵심 보안 메커니즘입니다. 동일 프로토콜, 동일 도메인(또는 IP), 동일 포트를 동일한 하나의 지역으로 보며, 한 지역 내의 스크립트는 해당 지역에 대한 권한만 가집니다. 즉, 해당 지역의 스크립트는 해당 지역 내의 리소스에 대해서만 읽고 쓸 수 있을 뿐 다른 지역의 리소스에 액세스할 수 없습니다. 이러한 보안 제한을 동일 원본 서버 정책이라고 합니다. 

#### 동일 원본 서버의 정의
두 페이지의 프로토콜, 도메인, 포트(포트를 지정한 경우)가 같은 경우 동일 원본 서버로 간주합니다. 아래 표에서 `http://www.example.com/dir/page.html`에 대한 동일 원본 서버 점검 예시를 참조하십시오.

| **URL** | **결과** | **원인** |
|:---------:|:---------:|:---------:|
| `http://www.example.com/dir2/other.html` | 성공 | 프로토콜, 도메인, 포트 동일 |
| `http://www.example.com/dir/inner/another.html` |	성공 | 프로토콜, 도메인, 포트 동일 |
| `https://www.example.com/secure.html` |	실패	| 프로토콜 상이(HTTPS) |
| `http://www.example.com:81/dir/etc.html` |	실패 |	포트 상이(81) |
|`http://news.example.com/dir/other.html` |	실패 |	도메인 상이 |

#### 크로스 도메인 액세스
도메인 간 리소스 공유(Cross-Origin Resource Sharing, CORS, 약칭 '크로스 도메인 액세스')는 Web 애플리케이션 서버가 도메인 간 액세스를 제어하도록 허용함으로써 도메인 간 데이터를 안전하게 전송하는 메커니즘입니다. CORS는 브라우저와 서버의 지원이 필요합니다. 현재 모든 서버가 해당 기능을 지원하며, IE 브라우저는 IE10 이상 버전이 요구됩니다.
CORS 전체 통신 과정은 브라우저에서 자동으로 이루어지며 사용자의 개입이 필요하지 않습니다. 개발자에게 있어 CORS 통신은 동일 원본 서버의 AJAX 통신과 차이가 없고 코드도 완전히 동일합니다. AJAX의 크로스 도메인 요청을 확인한 브라우저는 부수적인 헤더 정보를 자동으로 추가하고, 부수적인 요청을 한 번 더 할 때도 있으나 사용자는 알아차리지 못합니다.
따라서 CORS 통신의 핵심은 서버입니다. 서버가 CORS 인터페이스를 구축하면 원본 서버 간 통신이 가능합니다.

## CORS 주요 사용 시나리오
CORS는 반드시 브라우저를 사용할 때 써야 합니다. 액세스 권한을 제어하는 것은 브라우저이지 서버가 아니기 때문입니다. 따라서 기타 클라이언트를 사용할 때는 어떠한 크로스 도메인 문제도 신경 쓸 필요가 없습니다.
CORS의 주요 애플리케이션은 업로드 또는 다운로드에 상관없이 브라우저에서 AJAX를 사용해 직접 COS 데이터에 액세스하므로 사용자의 애플리케이션 서버를 거칠 필요가 없습니다. COS와 AJAX 기술을 모두 사용하는 웹 사이트의 경우 CORS를 사용해 COS와 직접 통신할 것을 권장합니다.

## CORS에 대한 COS의 지원
COS는 CORS 규칙 설정을 지원하고, 필요에 따라 상응하는 크로스 도메인 요청을 허용 또는 거부합니다. 해당 CORS 규칙 설정은 버킷 레벨에 속합니다.
CORS 요청의 통과 여부는 COS 인증과는 별개입니다. 즉, COS의 CORS 규칙은 CORS와 관련된 Header의 추가 여부를 결정하기 위한 규칙일 뿐입니다. 해당 요청의 차단 여부는 브라우저가 결정합니다.
현재 COS의 모든 Object 관련 인터페이스는 CORS에 대한 인증을 제공합니다. Multipart 관련 인터페이스 역시 CORS 인증을 지원합니다.
>?하나의 브라우저에서 각각 `www.a.com`과 `www.b.com`을 원본 서버로 하는 두 개의 페이지가 동시에 같은 크로스 도메인 리소스를 요청할 경우 `www.a.com`의 요청이 서버에 먼저 도착하면 서버는 리소스에 Access-Control-Allow-Origin의 Header를 추가하고 `www.a.com`의 사용자에게 반환합니다. 이때 `www.b.com`도 요청을 보내고, 브라우저는 Cache의 이전 요청에 대한 응답을 사용자에게 반환합니다. Header의 내용과 CORS의 요구가 매칭되지 않으면 `www.b.com`의 요청은 실패하게 됩니다.

## CORS 설정 예시
AJAX를 사용하여 COS에서 데이터를 획득하는 설정 순서의 간단한 예시를 소개합니다. 예시에서 사용한 버킷(Bucket) 권한은 공용(Public)으로 설정되어 있습니다. 액세스 권한이 개인인 버킷(Bucket)은 요청에 서명만 추가하면 되고, 나머지는 동일하게 설정됩니다.
아래 예시에서 사용한 버킷 이름은 corstest이고, 버킷 액세스 권한은 공개 읽기 및 개인 쓰기입니다.

### 준비 작업
1. **파일이 정상적으로 액세스되는지 확인합니다.**
test.txt 텍스트 파일 하나를 corstest에 업로드합니다. test.txt의 액세스 주소는 `http://corstest-125xxxxxxx.cos.ap-beijing.myqcloud.com/test.txt`입니다.
curl을 사용하여 해당 텍스트 파일에 액세스합니다. 아래 주소를 해당하는 파일 주소로 변경하십시오.
```
curl http://corstest-125xxxxxxx.cos.ap-beijing.myqcloud.com/test.txt
```
test.txt 파일에 반환된 내용은 test입니다. 해당 문서에 정상적으로 액세스됨을 의미합니다.
![](https://main.qcloudimg.com/raw/d9e4cee0e6ac49d9774bab3be46bed46.png)
2. **AJAX 기술을 사용하여 파일에 액세스합니다.**
AJAX 기술을 사용하여 해당 test.txt 파일에 직접 액세스를 시도합니다.
 1. 간단한 HTML 파일을 만들고, 아래의 코드를 로컬로 복사하여 HTML 파일로 저장한 후 브라우저를 사용하여 엽니다. 사용자 정의 헤더가 설정되어 있지 않으므로 해당 요청은 사전 인증이 필요하지 않습니다.
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<body>
<a href="javascript:test()">Test CORS</a>
<script>
    function test() {
        var url = 'http://corstest-125xxxxxxx.cos.ap-beijing.myqcloud.com/test.txt';
        var xhr = new XMLHttpRequest();
        xhr.open('HEAD', url);
        xhr.onload = function () {
            var headers = xhr.getAllResponseHeaders().replace(/\r\n/g, '\n');
            alert('request success, CORS allow.\n' +
                'url: ' + url + '\n' +
                'status: ' + xhr.status + '\n' +
                'headers:\n' + headers);
        };
        xhr.onerror = function () {
            alert('request error, maybe CORS error.');
        };
        xhr.send();
    }
</script>
</body>
</html>
```
 2. 브라우저에서 해당 HTML 파일을 열고 [Test CORS]를 클릭하여 요청을 보내면 "액세스 권한이 없습니다."와 같은 오류 알림이 뜹니다. Access-Control-Allow-Origin Header를 찾을 수 없기 때문입니다. 서버에 CORS가 설정되지 않은 것이 이러한 오류의 원인입니다.
![](https://main.qcloudimg.com/raw/db84b59f4e48ec50b3b577fa116fe7ba.jpg)
 3. 액세스에 실패하면 Header 인터페이스로 돌아가 원인을 분석합니다. 브라우저가 발송한 Origin이 있는 Request를 볼 수 있으며, 이는 크로스 도메인 요청입니다.
![](https://main.qcloudimg.com/raw/0ba03fd90d9e6bb59785a6ba3b17d812.jpg)
>?서버에 웹 페이지를 구축합니다. 주소는 `http://127.0.0.1:8081`입니다. 따라서 Origin은 `http://127.0.0.1:8081`입니다.

### CORS 설정
액세스 실패의 원인이 확인되면 버킷 설정과 관련한 CORS를 통해 위의 문제를 해결할 수 있습니다. COS 콘솔은 CORS 설정을 할 수 있고, 본 예시는 콘솔을 사용해 CORS 설정을 완료합니다. CORS 설정이 특별히 복잡하지 않다면 콘솔을 사용한 CORS 설정을 권장합니다.
1. COS 콘솔에 로그인하여 설정 페이지로 이동합니다.
[COS 콘솔](https://console.cloud.tencent.com/cos5)에 로그인한 후 [버킷 리스트]를 클릭하여 관련 버킷으로 이동합니다. [기본 설정] 탭을 클릭하고 아래로 드래그하면 '크로스 도메인 액세스 CORS 설정 항목'을 확인할 수 있습니다.
2. CORS 규칙을 활성화하여 설정합니다. 
[규칙 추가]를 클릭하여 첫 번째 규칙을 추가합니다. 가장 느슨한 설정은 다음과 같습니다.
>CORS 설정은 규칙들로 구성되어 있습니다. 첫 번째 항목부터 하나씩 매치해 나가다가 가장 먼저 매치되는 규칙을 기준으로 합니다.

#### 인증 결과
설정이 완료되면 test.txt 텍스트 파일에 다시 액세스해봅니다. 결과가 다음과 같으면 정상적으로 액세스 요청이 가능합니다.

### 장애 삭제 및 권장 사항
크로스 도메인으로 인해 발생하는 액세스 문제를 없애고 싶다면 CORS 설정을 위와 같이 가장 느슨하게 설정합니다. 해당 설정은 모든 크로스 도메인 요청을 허용합니다. 해당 설정에서도 계속 오류가 발생하는 경우 CORS가 아닌 다른 부분에서 오류가 발생했음을 의미합니다.

가장 느슨한 설정 외에도 더 세밀한 제어 메커니즘을 설정하여 맞춤형 제어를 할 수 있습니다. 예를 들어, 본 예시에서는 다음과 같이 최소한의 설정을 통해 맞춤형 제어가 가능합니다.
따라서 대다수 시나리오의 경우 개인의 사용 시나리오에 따라 최소한의 설정으로 보안성을 확보하실 것을 권장합니다.
## CORS 설정 항목 설명
CORS 설정에는 다음과 같은 항목이 있습니다.
#### 소스 Origin
크로스 도메인 요청을 허용합니다.
- 동시에 여러 원본 서버를 지정할 수 있으며, 한 줄에 하나만 입력할 수 있습니다.
- 설정은 `*`를 지원합니다. 모든 도메인을 허용한다는 의미이지만 권장하지 않습니다.
- `http://www.abc.com`과 같은 특정 도메인을 지원합니다.
- `http://*.abc.com`과 같은 레벨 2의 와일드카드 서브도메인을 지원합니다. 단, 한 줄에 하나의 `*`만 있어야 합니다.
- 프로토콜명 HTTP 또는 HTTPS를 누락하지 않도록 주의하십시오. 기본값 80의 포트가 아닌 경우 포트가 필요합니다.

#### Methods
모두 허용된 크로스 도메인 요청 방법입니다(단일 또는 다수).
예: GET, PUT, POST, DELETE, HEAD

#### Allow-Header
허용된 크로스 도메인 요청 Header입니다.
- 동시에 여러 원본 서버를 지정할 수 있으며, 한 줄에 하나만 입력할 수 있습니다.
- Header는 쉽게 누락될 수 있습니다. 별도의 요구 사항이 없는 한 전체를 허용한다는 의미의 `*`로 설정하길 권장합니다.
- 대소문자를 구분하지 않습니다.
- Access-Control-Request-Headers에서 지정된 모든 Header는 반드시 Allowed-Header에 상응하는 항목이 있어야 합니다.

#### Expose-Header
브라우저에 노출된 Header 리스트는 사용자가 응용 프로그램에서 액세스한 응답 헤더입니다(예: Javascript의 XMLHttpRequest 객체).
- 구체적인 설정은 애플리케이션의 필요에 따라 확정해야 합니다. 기본값으로 Etag 입력을 권장합니다.
- 와일드카드 부호 사용은 허용하지 않습니다. 대소문자를 구분하지 않으며, 항목별로 하나만 입력할 수 있습니다.

#### 시간 초과 Max-Age
브라우저가 특정 리소스의 사전 획득 요청(OPTIONS 요청)에 대한 결과를 반환하는 캐시 시간으로 단위는 초입니다. 특수한 상황이 아닌 경우 약간 크게(예: 60초) 설정할 수 있으며, 해당 항목은 선택 설정 항목입니다.
