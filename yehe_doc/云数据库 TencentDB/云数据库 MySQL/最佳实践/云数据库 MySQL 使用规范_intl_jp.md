## 目的
- TencentDB for MySQLの管理とメンテナンスを規範化して、不適切な操作でTencentDB for MySQLが使えなくなるといった影響が起きないようにします。
- データベース開発者を指導してSQLを合理的に作成し、TencentDB for MySQLの性能を最大限に発揮させます。

## 権限管理ルール
- TencentDB for MySQLの安定性とセキュリティを確保するために、TencentDB for MySQLはスーパー、シャットダウン、およびファイル権限を制限します。setステートメントを実行すると、次のエラーが発生する場合があります。  
```
#1227-Access denied;you need(at least one of)the SUPER privilege (s) for this operation
```     
解決方法：「set」を使用して関連するパラメーターを変更する必要がある場合は、コンソールのインスタンス管理画面の【データベース管理】>【パラメータ設定】に移動してください。修正が必要なパラメータがその中になければ、[チケットを提出](https://console.cloud.tencent.com/workorder/category)して評価後修正をサポートし、インスタンスの安定性を確保します。
- - 必要に応じて権限を付与、一般のアプリケーションプログラムにDML（SELECT、UPDATE、INSERT、DELETE）権限を付与するだけで十分です。
- 一般のアプリケーションプログラムのアクセスユーザーはデータベースレベルによって権限を付与します。
- 認証されたユーザーが特定のIPまたはIP範囲からのみアクセスできるようにします。コンソールにセキュリティグループを設定して制限することができます。セキュリティグループの設定は、必ずコンソールのプロンプトが示した基準に従い操作してください。パブリックネットワークアクセス用のセキュリティグループを設定するケースでは、すべての関連する出口IPを必ず開いてください。
- 管理と開発に異なるアカウントを使用します。

## 日常操作のルール
### 注意事項
- インスタンスのセキュリティを強化するには、弱いパスワードを使用しないでください。
- プライベートネットワーク経由でログインする場合は、クライアントのCVMインスタンスとTencentDB for MySQLインスタンスが同一アカウント、同一リージョンにあることを確認してください。
- コンソールからダウンロードされたバイナリログをローカルで解析する必要がある場合は、クライアントのMySQLバージョンとTencentDB for MySQLインスタンスのバージョンが一致していることを必ず確認してください。一致していない場合、解析において文字化けが生じますので、mysqlbinlog 3.4以降のバージョンを使用することをお勧めします。
- コールドバックアップファイルをコンソールのプライベートネットワーク経由でCVMインスタンスにダウンロードする場合は、URLを引用符で囲みます。そうしないと、404エラーが発生します。

### 提案事項
- ピーク時にオンラインDDL操作を実行しないでください。`pt-online-sche-machange`などのツールを使用できます。
- ピーク時にバッチ処理を実行しないでください。
- 1つのインスタンスで多くのタスクを行うことは極力避けてください。結合係数が高すぎると、タスク間で相互に影響し合うリスクが生じます。
- 誤操作によるデータ消失のリスクを軽減するために、自動トランザクションコミットを無効にし、オンライン操作ではbeginを使用する習慣を身に付けることをお勧めします。誤操作も、TencentDB for MySQLのロールバック機能を使用してデータを復元できます（過去5日間の任意の時点へのロールバックがサポートされています）。関連テーブルがクロスデータベースやクロステーブルのロジックが含まれていない場合は、クイックロールバックまたはインスタントロールバックを使用してデータを速やかに復元します。ロールバックで新しく生成したデータベーステーブル名は、デフォルトで`元のテーブル名_bak`です。
- 業務に推進活動などがある場合は、リソースを事前に予想し、インスタンス関連の最適化を行ってください。リソースに対する大きな需要がある場合は、Tencent Cloudの営業担当者に適時連絡してください。


## データベースとテーブルの設計ルール
### 注意事項
- TencentDB for MySQL 5.6およびそれ以上のバージョンではMyISAMエンジンおよびMemoryエンジンをサポートしません。Memoryエンジンのニーズがあれば、TencentDB for RedisまたはMemcachedを使用することをお勧めします。自作データベースをTencentDB for MySQLに移行すると、MyISAMエンジンは移行中に自動的にInnoDBエンジンに変換されます。
- 自動インクリメント列を含むテーブルの場合、自動インクリメント列に個別のインデックスが存在する必要があります。複合インデックスを使用する場合は、自動インクリメント列は先頭になければなりません。
- `row_format`必ず非固定にしてください。
- 各テーブルには必ず主キーがなければならず、適切な列を主キーに選択できなくても、意味のない列を主キーとして追加する必要があります。 MySQL第一モデル基準によると、主キー値は標準のInnoDBセカンダリインデックスのリーフノードに保存されます。インデックスが占めるディスク容量を減らし、効率を向上させるために、主キーとして短い自動インクリメント列を使用することをお勧めします。 `binlog_format`が rowの場合、主キーなしでデータを一括削除すると、重大なマスタースレーブ遅延が発生する可能性があります。
- フィールドをNOT NULLとして定義し、デフォルト値を設定します。NULLフィールドはインデックスを利用できなくなり、SQL開発に多くの問題を引き起こします。 NULL計算は、IS NULLおよびIS NOT NULLに基づいてのみ実装できます。

### 提案事項
- ビジネスシナリオ分析とデータアクセスの見積もり（データベースの読み取り/書き込みQPS、TPS、ストレージを含む）を通じて、データベースが使用するリソースを合理的に計画します。 コンソールのクラウド監視画面でTencentDB for MySQLインスタンスの各監視を設定することもできます。
- データベースを構築する原則は同一種類のタスクのテーブルを1つのデータベースに入れ、混同しないようにしてください。 プログラムではデータベース間の関連操作を実行することは極力避けます。実行すると、今後のクイックロールバックにも一定の影響があります。
- 文字化けのリスクを最小限に抑えるために、utf8mb4文字セットを使用してください。複雑な一部の漢字と絵文字の表情はutf8mb4を使うと正しく表示されます。文字セットが変更された場合、新しい文字セットは変更後に作成されたテーブルでのみ有効になります。新しく購入したTencentDB for MySQLインスタンスを初期化するときはutf8mb4を選択することをお勧めします。
- 10進数フィールドの場合、decimalタイプの使用を推奨します。floatとdoubleは精度が低いので、特に金額のタスクに関するものはdecimalを必ず使用してください。
- データベースtext/blobを使用して大きなテキスト、バイナリデータ、画像、ファイルなどのコンテンツを保存することは極力避けてください。これらのデータはローカルディスクファイルに保存し、データベースにはそのインデックス情報だけを保存します。
- 外部キーの使用は避けてください。アプリケーション層で外部キーのロジックを実現することをお勧めします。外部キーとカスケード更新は、挿入のパフォーマンスを低下させ、同時実行数が多い場合にデッドロックを引き起こす可能性があるため、同時実行数が多いシナリオには適していません。
- ビジネスロジックとデータストレージの結合度を下げ、データベースには主にデータを保存します。ビジネスロジックは可能な限りアプリケーション層を介して実行します。移植性とスケーラビリティが低いため、ストレージプロセス、トリガー、関数、イベント、ビュー、およびその他の高度な機能の使用を最小限に抑えます。このようなオブジェクトがインスタンスに存在する場合、アカウントの移行とdefinerの不一致に起因する移行の失敗を回避するために、デフォルトではdefinerを設定しないことをお勧めします。　　
- 短期タスクが大きな量にならない場合は、パーティションテーブルを使用しないでください。パーティションテーブルは主にアーカイブ管理に使用され、宅配業やeコマース業の発注書に多く使われます。パーティションテーブルには性能を向上させる作用はありません。
- 読み取り負荷が高く、整合性の要件が低いビジネスシナリオ（秒レベルのデータ遅延は許容範囲）では、読み取り専用インスタンスを購入して、データベースレベルで読み取り/書き込みの分離を実装することをお勧めします。

## インデックス設定ルール
### 注意事項
- 非常に頻繁に更新され、高度に区分化されていない列にインデックスを作成することを禁止します。記録の更新によりB+ツリーが変更されます。更新が頻繁なフィールドでのインデックス作成はデータベースのパフォーマンスを大幅に低下させます。
- 複合インデックスを作成するときは、高度に区分化された列をインデックスの最も左側に置きます。例えば、`select xxx where a = x and b = x;`，aとbを一緒に組み合わせてインデックスを作成し、aの区分度をさらに高めて、`idx_ab(a,b)`を作成します。不等号と等号の判断条件が混在するときは、等号条件を持つ列を前に置く必要があります。例えば、`where a xxx and b = xxx`の場合、インデックスaはクエリで使用されないため、インデックスaの区分度が高くても、bをインデックスの最前列に配置する必要があります。

### 提案事項
- 単一テーブルのインデックス数は5個以下に、インデックス1つあたりのフィールド数は5個以下とすることをお勧めします。インデックスが多すぎると、フィルター機能が働かず、インデックスも空間を占めてしまい、管理してもリソースを消耗してしまうからです。
- カーディナリティ値が高いSQLフィルターに最も頻繁に使用される列にインデックスを作成します。SQLフィルターに関係しない列にインデックスを作成しても意味がありません。フィールドの一意性が高いほど、カーディナリティ値が高くなり、インデックスのフィルター効果も良くなります。通常、カーディナリティが10％未満のインデックス列は、性別フィールドなどの非効率なインデックスと見なされます。
- varcharフィールドにインデックスを作成するときは、インデックスの長さを指定することをお勧めします。すべての列にインデックスは直接作成しないでください。一般にvarchar列は比較的長く、一定の長さを指定してのインデックス作成はすでに区分度が高いので、すべての列にインデックスをつける必要はありません。すべての列へのインデックス作成は重くなり、インデックスのメンテナンスコストが増加してしまいます。count(distinct left(列名、インデックスの長さ))/count(\*)を使用してインデックス区分度を見ることができます。
- 冗長なインデックスを使用しないでください。 2つのインデックス(a、b) (a)が同時に存在する場合、(a)は冗長なインデックスと見なされます。クエリフィルター条件がa列なら、(a、b)インデックスは十分で、単独で(a)インデックスを作成する必要はありません。
- カバリングインデックスを適切に使用して、IOオーバーヘッドを低減させます。InnoDBでは、セカンダリインデックスのリーフノードは、自身のキー値と主キー値のみを保存します。SQLステートメントがそのようなインデックス列または主キーをクエリしない場合、インデックスのクエリは対応する主キーを最初に検索し、次に主キーに基づいて必要な列を検索します。これはテーブルアクセス( TABLE ACCESS BY INDEX ROWID )で、こうして想定外のIOオーバーヘッドが発生しますが、この時カバリングインデックスを利用してこの問題を解決できます。例えば`select a,b from xxx where a = xxx`において、aが主キーでない場合、aおよびb列に複合インデックスを作成して問題を回避できます。

## SQL作成規範
### 注意事項
- LIMITはランダムであり、データエラーを引き起こす可能性があるため、UPDATEおよびDELETE操作にLIMITを使用しないでください。代わりに、完全に一致するような操作にはWHEREを使用する必要があります。
- `INSERT INTO t_xxx VALUES(xxx)`の使用は禁止します。テーブル結合の変化がデータエラーを出すことを避けるため、挿入した列の属性を明確に指定する必要があります。
- 無効なインデックスの一般的な理由は次のとおりです。
 - 暗黙的な型変換。例えば、インデックスaのタイプはvarcharで、SQLステートメントがwhere a = 1の場合、varcharはintに変更されます。
 - インデックス列に数学計算と関数などの操作を行います。例えば、日付列の関数を使用してフォーマット処理を行います。
 -  結合操作が実行される列には、異なる文字セットがあります。
 -  複数の列の配列順序が不一致の問題。例えば、インデックスが(a、b)で、SQLステートメントがorder by a b desclike。
 -  あいまい検索を実行すると、一部のインデックスで`xxx%`の形式の文字をクエリできます。
 -  逆方向の検索を使用（not，!=，not in 等）します。
 
### 提案事項
- 次の問題を回避するために、必要に応じてクエリを実行し、`select *`を拒否してください。       
    - カバリングインデックスが機能せず、TABLE ACCESS BY INDEX ROWIDの問題が発生し、余分なIOオーバーヘッドが発生します。      
    - 想定以上にメモリ負担があるため、多くのコールドデータが`innodb_buffer_pool_size`にインポートされるため、クエリのヒット率が低下する可能性があります。      
    - 想定以上のネットワーク伝送オーバーヘッド。
- 大きなトランザクションの使用は避けてください。マスター/スレーブ遅延問題を回避するために、大きなトランザクションを複数の小さなトランザクションに分割することをお勧めします。
- ビジネスコードのトランザクションを適時にコミットし、不必要なロックが生じないようにします。
- 複数のテーブルでの結合操作の使用を最小限に抑え、大きなテーブルでは結合操作を実行しないでください。 2つのテーブルで結合操作を実行する場合は、小さい方のテーブルを駆動表として使用し、結合する列の文字セットを同じにし、それらすべてにインデックスを付ける必要があります。
- LIMITを使用してページングを最適化します。「LIMIT 80000、10」という操作は、80010レコードを取り出し、最後の10レコードを返すことです。これにより、データベースに高い負荷がかかる場合があります。ページング前に最初のレコードを見つけることをお勧めします。例：`SELECT * FROM test WHERE id = ( SELECT sql_no_cache id FROM test order by id LIMIT 80000,1 ) LIMIT 10 ;。
- マルチレベルのネストされたサブクエリでSQLステートメントを使用しないでください。 MySQL 5.5より前のクエリオプティマイザがinをexistsに変更すると、インデックスエラーになります。この場合、外部テーブルが大きいとパフォーマンスが低下する可能性があります。

>
>- 上記のような状況を完全に避けることは困難です。推奨される　　このタイプの条件を主要なフィルタリング条件として使用しないことです。
>- 多数の全表スキャンがある場合は、コンソールで`log_queries_not_using_indexes`パラメーターを設定し、しばらくしてからスローログファイルをダウンロードして分析します。しかし、スロークエリーログが急増しないように長時間の起動はしないでください。
>- タスクがオンラインになる前に、必要なSQL監査を行い、日常のメンテナンスでは定期的にスロークエリログをダウンロードして対象を絞った最適化を行います。
