## 目的
- クラウドデータベースMySQLの管理とメンテナンスを規範化して、不適切な操作でクラウドデータベースMySQLが使えなくなるといった影響が起きないようにします。
- データベース開発者を指導してSQLを合理的に作成し、クラウドデータベースMySQLの性能を最大限に発揮させます。

## 権限管理ルール
- クラウドデータベースMySQLの安定性とセキュリティを考慮し、クラウドデータベースMySQLはsuper、shutdown、file権限を制限します。クラウドデータベースMySQL上でsetステートメントを実行すると、次のようなエラーメッセージが現れることがあります。  
```
#1227-Access denied;you need(at least one of)the SUPER privilege (s) for this operation
```     
解決方法：setの関連パラメータの修正が必要な場合は、コンソールのインスタンス管理画面の【データベース管理】>【パラメータ設定】機能を使用して完了し、修正が必要なパラメータがその中になければ、[チケットを提出](https://console.cloud.tencent.com/workorder/category) して評価後修正をサポートし、インスタンスが安定するようにします。
- - 認証する必要に応じて、一般のアプリケーションプログラムではDML（SELECT、UPDATE、INSERT、DELETE）権限のみ認証します。
- 認証の対象は最も少なくするという原則により、一般のアプリケーションプログラムのアクセスユーザーはデータベースのランクによって認証します。
- 認証されたユーザーがアクセスしたときは、IPまたはIP区画のアクセス特定のみを許可し、コンソールにセキュリティグループを配置して制限することができます。セキュリティグループの設定は、必ずコンソールのプロンプトが示した基準に従い操作してください。公式サイトのアクセスでセキュリティグループを設定するケースでは、すべての関連する出口IPを必ず開いてください。
- 管理アカウントと開発アカウントを分ける。

## 日常操作のルール
### 注意事項
- 脆弱なパスワードは使用禁止とし、データベースインスタンスのセキュリティを引き上げてください。
- 内部ネットワークの接続ログインでは、クライアント端末のクラウドサーバーCVMとクラウドデータベースMySQLが同一アカウント、同一リージョンであることを必ず確認してください。
- コンソールからダウンロードしたbinlogログは、ローカルで解析が必要な場合、クライアント端末MySQLバージョンとクラウドデータベースMySQLインスタンスバージョンが一致していることを必ず確認してください。一致していない場合、解析において文字化けが生じますので、3.4またはそれ以上のバージョンのmysqlbinlogを使用することをお勧めします。
- コンソール上で内部ネットワークによってCVMのコールドスタンバイのファイルをダウンロードするときは、引用符を用いてurlを挟んでください。挟まない場合、404エラーメッセージが出ます。

### 提案事項
- タスクのピーク時におけるonline ddl操作は極力避けてください。使用できるツールについては`pt-online-sche-machange`をご参照ください。
- タスクのピーク時におけるバッチ処理は極力避けてください。バッチ処理はタスクが少ないときが適しています。
- 1つのインスタンスで多くのタスクを行うことは極力避けてください。結合係数が高すぎると、タスク間で相互に影響し合うリスクが生じます。
- タスクの自動トランザクションを停止することをお勧めします。オンライン操作では`begin;`を先行する習慣をつけ、誤操作によるデータ消失のリスクを減らしてください。誤操作もまたクラウドデータベースMySQLのロールバック機能（現在5日以内の任意の時間にロールバックをサポート）を使用します。関連テーブルがクロスデータベースやクロステーブルのロジックに関連しない場合、クイックロールバックまたはインスタントロールバックを使用してデータを速やかにリストアします。ロールバックで新しく生成したデータベーステーブル名のデフォルトは`元データベーステーブル名_bak`です。
- 業務に推進活動などがある場合は、リソースを事前に予想し、インスタンス関連の最適化を行ってください。需要が大きいときは担当のサービスマネージャーに適時連絡してください。


## データベース、テーブルの設計ルール
### 注意事項
- クラウドデータベースMySQL 5.6およびそれ以上のバージョンではMyISAMエンジンおよびMemoryエンジンをサポートしません。Memoryエンジンのニーズがあれば、クラウドデータベースRedis、Memcachedの使用をお勧めします。自身で作成したデータベースをクラウドデータベースMySQLにマイグレーションした場合、自動でMyISAMエンジンをInnoDBエンジンに転換します。
- 自動インクリメントカラムがあるテーブルでは、自動インクリメントカラムに個別のインデックスが必要で、複合インデックスを使用している場合、自動インクリメントカラムは先頭になければなりません。
- `row_format`必ず非fixedにしてください。
- 各テーブルには必ず主キーがなければならず、適切な列を主キーに選択できなくても、1つの意味のない列を主キーに追加してください。MySQL第一モデル基準InnoDBの補助インデックスリーフノードは1つの主キー値を保存し、短い自動インクリメントを主キーにすることを推奨します。インデックスが占めるディスク容量を小さくして効率を向上させてください。`binlog_format`をrowとするユースケースで、大量にデータを削除するとマスター、スレーブに重大なレイテンシーが生じます。
- フィールドは極力NOT NULLに定義し、デフォルト値を追加します。NULLはSQL開発に多くの問題をもたらしインデックスにアクセスしません。NULLの計算時はIS NULLとIS NOT NULLだけを使って判断します。

### 提案事項
- タスクユースケースの分析とデータアクセス（データベース読み書きQPS、TPS、ストレージ空間等）の予測を通じて、適切にデータベースを規範化し、リソースを使用します。コンソールのクラウド監視画面でクラウドデータベースMySQLインスタンスの各監視を設定することもできます。
- データベースを構築する原則は同一種類のタスクのテーブルに1つのデータベースを配置することです。タスクが異なるテーブルで同一のデータベースを共有すること、ならびにプログラムではデータベース間の関連操作を実行することは極力避けます。こうした操作は今後のクイックロールバックにも一定の影響があります。
- 文字セットは文字化けのリスクを減らすためutf8mb4を統一使用します。複雑な一部の漢字と絵文字の表情はutf8mb4を使うと正しく表示されます。文字セットの修正は修正後に作成するテーブルでのみ有効になるので、新しく購入したクラウドデータベースMySQLのインスタンスを初期化するときはutf8mb4を選択することをお勧めします。
- 小数字フィールドにはdecimalタイプの使用を推奨します。floatとdoubleは精度が低いので、特に金額のタスクに関するものはdecimalを必ず使用してください。
- データベース内においてtext/blobを使用して大きなテキスト、バイナリデータ、画像、ファイルなどのコンテンツを保存することは極力避けてください。これらのデータはローカルディスクファイルに保存し、データベースにはそのインデックス情報だけを保存します。
- 外部キーは極力使用せず、アプリケーション層で外部キーのロジックを実現することをお勧めします。外部キーとカスケード接続の更新は、同時発生率が高いケースには適していません。挿入性能が低下し、同時に大量発生した場合、デッドロックが発生しやすくなります。
- タスクロジックとデータストレージの結合度を下げ、データベースには主にデータを保存します。タスクロジックは可能な限りアプリケーション層を介して実行します。ストレージプロセス、トリガー、関数、event、ビュー等の高度な機能の使用は、これらの機能の移殖性、拡張性を下げることになります。インスタンスにこの種のオブジェクトがある場合、アカウントのマイグレーションとdefinerの不一致に起因するマイグレーションエラーを避けるため、デフォルトではdefinerを設定しないことをお勧めします。
- 短期タスクが大きな量にならない場合は、ブロック分担テーブルの使用禁止をお勧めします。ブロック分担テーブルは主にアーカイブ管理に使用され、宅配業やeコマース業の発注書に多く使われます。タスクの80％以上のクエリがブロック分担フィールドにアクセスすることを除き、分担テーブルには性能を向上させる作用はありません。
- 読み取りストレスが大きく、一致性リクエストが低い（秒レベルのデータ遅延は許容範囲）タスクケースについて、読み出し専用インスタンスをデータベースから購入し、読み書き分離ポリシーを実現することをお勧めします。

## インデックス設定ルール
### 注意事項
- 非常に頻繁に更新され、高度に区分化されていない列にインデックスを作成することを禁止します。記録の更新によりB+ツリーが変更されます。更新が頻繁なフィールドでのインデックス作成はデータベース性能を大幅に低下させます。
- 複合インデックスを作成するときは、高度に区分化された列をインデックスの最も左側に置きます。例えば、`select xxx where a = x and b = x;`，aとbを一緒に組み合わせてインデックスを作成し、aの区分度をさらに高めて、`idx_ab(a,b)`を作成します。不等号と等号の判断条件が混在するときは、等号条件の列を前に置いてください。例えば、`where a xxx and b = xxx`であれば、インデックスaにアクセスしないので、インデックスaの区分度が高くても、bをインデックスの最前列に置きます。

### 提案事項
- 単一テーブルのインデックス数は5個以下に、一つのインデックスフィールド数は5個以下とすることをお勧めします。多すぎるとフィルター機能が働かず、インデックスも空間を占めてしまい、管理してもリソースを消耗してしまうからです。
- タスクのSQLフィルターが最も多く、cardinality値が比較的高い列の作成インデックスを選択します。タスクSQLがアクセスしない列作成インデックスは意味がなく、フィールドの唯一性が高いほど、代表的なcardinality値は高くなり、インデックスのフィルター効果も良くなります。一般のインデックス列のcardinalityレコード数が10％未満の場合、効率が悪いインデックスと考えられます。例えば、性別フィールドです。
- varcharフィールド上にディレクトリをつくるときは、インデックスの長さを指定することをお勧めします。すべての列にインデックスは直接作成しないでください。一般にvarchar列は比較的長く、一定の長さを指定してのインデックス作成はすでに区分度が高いので、すべての列にインデックスをつける必要はありません。すべての列へのインデックス作成は重くなり、インデックスのメンテナンスコストが増加してしまいます。count(distinct left(列名, インデックスの長さ))/count(\*)を使用してインデックス区分度を見ることができます。
- インデックスの冗長は避け、2つのインデックス(a,b) (a)が同時に存在するときは、(a)はインデックスの冗長なredundant indexに属し、クエリフィルター条件がa列なら、(a,b)インデックスは十分で、単独で(a)インデックスを作成する必要はありません。
- インデックスカバーを適切に利用してIOのオーバーヘッドを低減させます。InnoDBの2級インデックスリーフノードは元々のキー値と主キー値だけを保存し、SQLクエリがインデックス列または主キーでない場合、このインデックスは対応する主キーを探してから主キーを基に必要な列を探します。これがテーブルリターンで、こうして想定外のIOオーバーヘッドが発生しますが、この時インデックスカバーを利用してこの問題を解決できます。例えば`select a,b from xxx where a = xxx`において、aが主キーでない場合、a,b2列の複合インデックスを作成でき、こうすればテーブルリターンすることはありません。

## SQL作成規範
### 注意事項
- UPDATE、DELETE操作ではLIMITは使用せず、WHEREにアクセスして適切に配置する必要があります。LIMITはランダムで、この種の操作はデータエラーに繋がります。
- `INSERT INTO t_xxx VALUES(xxx)`の使用は禁止します。テーブル結合の変化がデータエラーを出すことを避けるため、挿入した列の属性を明確に指定する必要があります。
- インデックスエラーをもたらすSQL言語が最もよく見られる状況には注意が必要です。
 - 間接的なタイプ転換です。例えば、インデックスaのタイプはvarchar，SQL言語でwhere a = 1; varcharと記入しintに変化しています。
 - インデックス列に数学計算と関数などの操作を行います。例えば、日付列の関数を使用してフォーマット処理を行います。
 -  join列文字セットの不統一
 -  複数の列の配列順序が不一致の問題。例えば、インデックスが(a,b)で、SQL言語がorder by a b desclike。
 -  あいまい検索の使用時は、文字符号が`xxx%`の形式で一部のインデックスを調べます。その他の状況ではインデックスを調べません。
 -  逆方向の検索を使用（not，!=，not in 等）。
 
### 提案事項
- 必要に応じて要求し、`select *`を拒否し、以下の問題を回避します：       
    - インデックスカバーなし、テーブルリターン操作をして、I/Oを追加します。      
    - 想定以上にメモリ負担があるため、多くのコールドデータを`innodb_buffer_pool_size`に注入し、クエリ命中率を引き下げます。      
    - 想定以上のネットワーク伝送オーバーヘッド。
- 大きなタスクでの使用は極力避けるようにし、大きなタスクは小さく分けてマスター、スレーブのレイテンシーを回避することをお勧めします。
- タスクコードでタスクは随時提出し、不必要なロックが生じないようにします。
- 多くのテーブルのjoinの使用は控え、大テーブルでのjoinは禁止し、2つのテーブルのjoin は小テーブルから駆動表を作り、join列は文字コードセットの一致とともにインデックスを作成する必要があります。
- LIMITページング最適化、LIMIT 80000，10。このような操作は80010レコードを取り出し、10レコードに戻します。データベースへの負担が大きいため、初めに記録した位置でページングすることを推奨します。例：`SELECT * FROM test WHERE id = ( SELECT sql_no_cache id FROM test order by id LIMIT 80000,1 ) LIMIT 10 ;`。
- 多階層のクエリでネストされたSQL言語を避けるため、MySQL 5.5の前のクエリ最適化マシンがinをexistsに変更すると、インデックスエラーになります。外部テーブルが大きい場合、性能は落ちます。

>
>- 上記のような状況を完全に避けることは困難です。推奨される解決策は、このタイプの条件を主要フィルター条件に設定しないことです。インデックスの主要フィルター条件に従うことは問題ではなりません。
>- 監視により、すべてのテーブルのスキャン量が大きいことが判明した場合、コンソールパラメータで`log_queries_not_using_indexes`を設定し、しばらくしてからスローログファイルをダウンロードして分析します。しかし、スロークエリーログが急増しないように長時間の起動はしないでください。
>- タスクがオンラインになる前に、必要なSQL審査を行い、日常のメンテナンスでは定期的にスロークエリログをインストールして対象を絞った最適化を行います。
