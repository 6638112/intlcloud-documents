
## 목적
- 규범화는 TencentDB for MySQL를 관리, 점검하여 잘못된 작업으로 인해 TencentDB for MySQL에 사용 불가능한 정도의 영향을 끼치지 않도록 합니다.
- 데이터베이스 개발자가 SQL을 합리적으로 작성하고, TencentDB for MySQL의 최적 성능을 발휘하도록 안내합니다.

## 권한 관리 규범
- TencentDB for MySQL의 안정성과 보안성을 고려하여 TencentDB for MySQL은 super, shutdown, file 권한을 제한합니다. 가끔 TencentDB for MySQL에서 set 명령을 실행할 경우 다음과 같은 오류가 발생하기도 합니다.  
```
#1227-Access denied;you need(at least one of)the SUPER privilege (s) for this operation
```     
해결 방법: set 수정 관련 매개변수가 필요한 경우, 콘솔 인스턴스 관리 페이지의 [Database Management]>[Parameter Settings] 기능을 사용해 완성할 수 있습니다. 수정해야 할 매개변수가 그 안에 없을 경우, [Submit Ticket](https://console.cloud.tencent.com/workorder/category) 동의 후 수정을 진행하여 인스턴스를 안정시킵니다.
- 필요에 따라 권한이 부여됩니다. 일반적으로 응용 프로그램은 DML(SELECT, UPDATE, INSERT, DELETE) 권한만 부여하면 사용 가능합니다.
- 권한 부여 객체 최소화가 원칙이며, 일반적인 응용 프로그램 액세스 사용자는 라이브러리 레벨에 따라 권한을 부여합니다.
- 사용자에게 액세스 권한을 부여할 때 특정 IP 또는 IP 필드 액세스만 허용합니다. 콘솔에서 보안 그룹을 설정하여 제한할 수 있으며, 보안 그룹의 설정은 반드시 콘솔에서 제시하는 기준에 따릅니다. 공용 네트워크 액세스로 보안 그룹 시나리오를 설정할 경우, 반드시 모든 관련 출력 IP를 개방하십시오.
- 계정 관리와 계정 개방은 분리됩니다.

## 상시 작업 규범
### 주의사항
- 데이터베이스 인스턴스 보안성 향상을 위해 보안이 약한 비밀번호 사용을 금지합니다.
- 내부 네트워크에 로그인하여 client 포트의 CVM이 TencentDB for MySQL과 동일한 계정, 동일한 리전의 기기임을 확인해야 합니다.
- 콘솔에서 다운로드한 binlog 로그를 로컬에서 분석해야 할 경우, 반드시 클라이언트 MySQL 버전과 TencentDB for MySQL 인스턴스 버전이 일치하는지 확인해야 합니다. 그렇지 않을 경우, 리졸브에 깨짐 현상이 있을 수 있으니 3.4 또는 그 이상 버전의 mysqlbinlog를 사용하시기를 권장합니다.
- 콘솔에서 내부 네트워크를 통해 CVM에서 콜드 스탠바이를 업로드/다운로드 할 때 url에 따옴표를 붙여 주시기 바랍니다. 그렇지 않을 경우 404 오류가 나타날 수 있습니다.

### 건의 사항
- 최대한 비즈니스 피크 시기를 피해서 online ddl 작업을 하시기 바랍니다. 사용 가능한 툴은 `pt-online-sche-machange`를 참고 바랍니다.
- 최대한 비즈니스 피크 시기를 피해 데이터 배치 작업을 하시고, 비즈니스 양이 많지 않은 기간에 나눠서 작업하시기 바랍니다.
- 1개의 인스턴스로 여러 작업을 진행하지 마시기 바랍니다. 커플링 정도가 지나치게 높으면 비스니스 간에 서로 영향을 끼칠 수 있습니다.
- 트랜잭션 자동 제출을 비활성화하고 온라인에서 `begin`을 먼저 선행하는 것을 권장합니다. 이는 오작동으로 인한 데이터 손실 위험을 낮춰줍니다. 오작동 역시 TencentDB for MySQL의 롤백 기능을 사용할 수 있습니다(현재 5일 이내 임의 시간대로 롤백을 지원합니다). 관련 테이블이 크로스 데이터베이스와 크로스 테이블의 로직에 연관되지 않을 경우, 빠른 롤백이나 터보 롤백으로 더욱 빨리 데이터를 복구할 수 있습니다. 롤백 후에 DB 테이블 이름은 '기존 DB 테이블 이름_bak'으로 생성됩니다.
- 서비스에는 홍보 이벤트 등이 있습니다. 미리 리소스를 예측하고, 인스턴스 관련 최적화를 해두시기 바랍니다. 수요가 비교적 많을 경우, 즉시 대응 서비스 매니저와 연락하시기 바랍니다.


## DB 테이블 설계 규범
### 주의사항
- TencentDB for MySQL 5.6 및 그 이상의 버전에서는 MyISAM 엔진과 Memory 엔진을 지원하지 않습니다. 만약 Memory 엔진의 수요가 있을 경우, TencentDB for Redis, Memcached를 사용하시길 권장합니다. 자체구축 데이터베이스가 TencentDB for MySQL로 마이그레이션 시, 자동으로 MyISAM 엔진을 InnoDB 엔진으로 변환합니다.
- Auto Increment가 존재하는 테이블의 경우, Auto Increment는 반드시 1개의 단독 인덱스에 있어야 합니다. 만약 복합 인덱스에 있으면 Auto Increment를 반드시 첫 번째에 두어야 합니다.
- `row_format`은 반드시 비 fixed를 보장해야 합니다.
- 모든 테이블에는 반드시 기본 키가 있어야 하며, 기본 키로 선택할 적합한 열이 없다고 해도 반드시 1개의 무의미한 열을 추가하여 기본 키를 만들어야 합니다. MySQL 첫 번째 표준형 기준은 InnoDB 보조 인덱스 페이지 노드에 기본 키 값을 저장하여 인덱스가 차지하는 디스크 용량은 낮추고, 효율은 높입니다. `binlog_format`이 row 형식인 상황에서 대량으로 기본키가 없는 데이터를 삭제할 경우 심각한 마스터/슬레이브 지연이 발생할 수 있습니다.
-필드를 최대한 NOT NULL로 정의하고 기본값을 더하면 NULL이 SQL 개발에서 여러 문제를 일으켜 인덱스 할 수 없게 됩니다. NULL 계산시 오직 IS NULL과 IS NOT NULL로만 계산됩니다.

### 건의 사항
- 서비스 시나리오 분석과 데이터 액세스(데이터 읽기/쓰기 QPS, TPS, 스토리지 용량 등) 예측을 통해 합리적으로 데이터베이스 사용 리소스를 계획하고, 콘솔 Cloud Monitoring 인터페이스에서도 TencentDB for MySQL 인스턴스의 각 옵션 모니터링을 설정할 수 있습니다.
- 데이터베이스 생성 원칙은 동일한 서비스의 테이블을 같은 데이터베이스에 두는 것입니다. 다른 서비스의 테이블은 최대한 같은 데이터베이스를 공용하지 않도록 합니다. 프로그램에서 크로스 데이터베이스 연결 작업을 실행하지 않도록 합니다. 해당 작업은 후속 빠른 롤백에도 일정 영향을 끼칩니다.
- 문자 세트는 일괄적으로 utf8mb4를 사용해 글자가 깨지는 위험을 줄입니다. 일부 복잡한 한자와 이모티콘은 반드시 utf8mb4 방식을 사용해 표시해야 합니다. 문자 세트를 수정하면 수정 후 생성하는 테이블에만 적용되므로, TencentDB for MySQL를 구매해 인스턴스를 초기화 할 경우 utf8mb4를 선택하실 것을 권장합니다.
- 작은 수 필드는 decimal 타입 사용을 추천합니다. float와 double은 정밀도가 부족하므로, 특히 금전과 관련된 비즈니스는 반드시 decimal을 사용히야 합니다.
- 데이터베이스에서 text/blob를 사용해 큰 단락의 텍스트, 이진법 데이터, 사진, 파일 등 내용을 저장합니다. 이러한 데이터들은 로컬 디스크 파일에 저장되며, 데이터베이스에는 인덱스 정보만 저장됩니다.
- 최대한 외래 키를 사용하지 마십시오. 응용 레이어에서 외래 키의 로직을 실행하시길 권장합니다. 외래 키와 cascading update는 동시 실행 시나리오에는 적합하지 않습니다. 삽입 성능을 저하시켜 대규모 동시 접속 시 데드 락이 생기기 쉽습니다.
- 비즈니스 로직과 데이터 스토리지의 동조화를 낮추고, 데이터베이스 스토리지 데이터를 위주로 합니다. 비즈니스 로직은 최대한 응용 레이어를 통해 실행하고, 스토리지 과정, 트리거, 함수, event, 뷰 등 고급 기능의 사용을 최소화합니다. 이러한 기능들은 이식성, 확장 가능성이 비교적 낮으므로 인스턴스에서 해당 객체가 존재할 경우, 기본 값을 definer로 설정하지 않는 것을 권장합니다. 마이그레이션 계정과 definer의 불일치로 마이그레이션이 실패할 수 있습니다.
- 단기간 내에는 비즈니스가 비교적 큰 등급에 도달하지 못하므로 파티션 사용을 금지할 것을 권장합니다. 파티션 테이블 용도는 보관 관리로, 주로 물류업과 전자 상거래 주문표에 사용됩니다. 파티션 테이블은 성능 향상 작용이 없고 비즈니스의 80% 이상이 파티션 필드 조회입니다.
- 읽기 스트레스가 크고, 일치성 요구가 비교적 낮은 (데이터 수신이 몇 초간 끊김) 비즈니스 시나리오는 읽기 전용 인스턴스를 구매해 데이터베이스에서 읽기/쓰기 분리 정책을 실행할 것을 권장합니다.

## 인덱스 설계 규범
### 주의사항
- 업데이트가 매우 빈번하고, 구분도가 높지 않은 열에 인덱스를 생성하는 것을 금지합니다. 기록 업데이트가 B-tree를 변경하고, 업데이트의 잦은 필드 인덱스 생성이 데이터베이스 성능을 크게 저하시킬 수 있습니다.
- 복합 인덱스 생성 시, 구분도가 가장 높은 열을 인덱스 가장 왼쪽에 둡니다. 예를 들어, `select xxx where a = x and b = x;`에서 a는 b와 함께 그룹 인덱스를 생성하나, a의 구분도가 훨씬 높고, 바로 `idx_ab(a,b)'를 생성합니다. 비등호와 등호가 혼합되어 조건을 판단할 때, 반드시 등호 조건의 열을 앞에 놓아야 합니다. "where a xxx and b = xxx"와 같이 a의 구분도가 훨씬 높다해도 반드시 b를 인덱스의 가장 앞 열에 놓아야 합니다. 그래야 인덱스 a까지 가지 않습니다.

### 건의 사항
- 단일 테이블의 인덱스 수는 5개를 초과하지 않는 것이 좋습니다. 단일 인덱스에서 필드 수는 5개를 초과하지 않아야 합니다. 너무 많으면 필터링을 할 수 없고, 인덱스도 용량을 차지하여 관리하는데 있어 리소스가 소모됩니다.
- 비즈니스의 SQL에서 가장 많이 필터되고, cardinality 값이 비교적 높은 열의 인덱스를 선택하십시오. 비즈니스 SQL에서 실행되지 않는 열에 생성한 인덱스는 아무 의미가 없습니다. 필드의 유일성이 높을수록 대표하는 cardinality 값도 높고, 인덱스 필터 효과도 좋아집니다. 일반적으로 인덱스 열의 cardinality 기록 수는 10% 미만입니다. 이 경우 이는 성별 필터처럼 저효율 인덱스라고 판단할 수 있습니다.
- varchar 필드에 인덱스를 만들 때, 인덱스 길이를 지정하면서 인덱스를 전체 열에 만들지 않기를 권장합니다. 일반적으로 varchar 열은 비교적 길며, 일정한 길이를 지정해 인덱스를 만들 경우 이미 구분도가 높기 때문에 전체 열에 인덱스 색인을 만들 필요가 없습니다. 전체 열에 인덱스를 생성하면 비교적 무거워져 인덱스 점검 비용이 커질 수 있습니다. count(distinct left(열명, 인덱스 길이))/count(\*)를 사용해 인덱스 구분도를 확인할 수 있습니다.
- 인덱스가 중복되는 것을 피하십시오. 두 개의 인덱스 (a,b) (a)가 동시에 존재한다면, (a)는 잉여 인덱스 redundant index에 속합니다. 조회 필터 조건이 a열이면, (a,b) 인덱스로 충분하니 (a) 인덱스를 단독으로 만들지 않아도 됩니다.
- 인덱스 덮어쓰기를 합리적으로 이용하여 IO 비용을 낮춥니다. InnoDB의 2단계 인덱스의 페이지 노드에는 키값과 기본 키 값만 저장합니다. 만약 1개의 SQL로 조회한 것이 인덱스 열이나 기본 키가 아닐 경우 이 인덱스를 이용해 먼저 상응하는 기본 키를 찾고, 그 다음 기본 키에 따라 찾으려는 열을 찾습니다. 이것이 flashback table입니다. 이렇게 하면 별도의 IO 비용이 추가될 수 있습니다. 이때 인덱스 덮어쓰기로 이 문제를 해결할 수 있습니다. 예를 들어, `select a,b from xxx where a = xxx`에서 만약 a가 기본 키가 아니라면 a, b 두 개 열이 있는 복합 인덱스를 생성하십시오. 이러면 flashback table 작업을 하지 않아도 됩니다.

## SQL 편집 규범
### 주의사항
- UPDATE, DELETE 작업은 LIMIT를 사용하지 않고, 반드시 WHERE를 이용해 정확히 매칭해야 합니다. LIMIT는 랜덤이며, 해당 작업은 데이터 오류를 일으킬 수 있습니다.
- `INSERT INTO t_xxx VALUES(xxx)` 사용을 금합니다. 테이블 구조 변동으로 인한 데이터 오류가 일어나지 않게 반드시 삽입하는 열의 속성을 명시적으로 지정해야 합니다.
- SQL 명령에서 가장 많이 보이는, 인덱스가 유효하지 않게 되는 상황에 주의하시기 바랍니다.
 - 내장 유형 전환, 인덱스 a의 유형이 varchar인 경우, SQL 명령은 where a = 1 = varchar에서 int로 바뀝니다.
 - 인덱스 열에 대해 수학 계산과 함수 등의 작업을 진행합니다. 예를 들어, 함수를 사용해 날짜 열을 포맷 처리합니다.
 -  join 열 문자 세트 불일치
 - 예를 들어 인덱스가 (a,b)이고, SQL 명령이 order by a b desclike와 같이 여러 열의 정렬 순서가 불일치하는 문제.
 - 사용 조회가 모호한 경우 문자 세트 유형 `xx%` 형식은 일부 인덱스에 도달할 수 있습니다. 다른 상황에서는 인덱스에 도달하지 않습니다.
 - 마이너스 방향 조회(not, !=, not in 등)를 사용합니다.
 
### 건의 사항
- 필요에 따라 `select *`을 거절하여 다음 문제를 피합니다.       
    - 인덱스 덮어쓰기, flashback table 작업, I/O 증가 불가      
    - 추가적인 메모리 부담, 대량의 콜드 데이터 `innodb_buffer_pool_size`로 가져와 조회 히트율 감소      
    -추가적인 네트워크 전송 비용
- 최대한 큰 트랜잭션 사용을 피합니다. 큰 트랜잭션을 작은 트랜잭션으로 나눠 마스터/슬레이브 지연을 피합니다.
- 비즈니스 코드의 트랜잭션을 제때 제출해 불필요한 Current-Lock 대기가 생기지 않도록 합니다.
- 다중 테이블 join을 적게 사용하고, 큰 테이블은 join을 금지합니다. 두 개의 테이블이 join 시 반드시 작은 테이블로 드라이버 테이블을 만듭니다. join 열은 반드시 문자 세트가 일치해야 하며 모두 인덱스가 있는 것을 생성해야 합니다.
- LIMIT 페이징 최적화, LIMIT 80000, 10종류의 이러한 작업은 80010개의 기록을 꺼낸 후 다시 10개로 되돌리는 것으로 데이터베이스의 부담이 큽니다. 먼저 첫 번째 기록의 위치를 확인하고 다시 페이지를 나누어 보는 것을 추천합니다. 예시: `SELECT * FROM test WHERE id = ( SELECT sql_no_cache id FROM test order by id LIMIT 80000,1 ) LIMIT 10 ;`
- 다중 레이어가 중복으로 SQL 명령을 조회하는 것을 피합니다. MySQL 5.5 이전의 쿼리 옵터마이저가 in을 exists로 변경할 수 있으며, 인덱스가 유효하지 않게 될 수 있습니다. 외부 테이블이 크면 성능이 저하됩니다.
>?
>- 위와 같은 상황을 완전히 피하기는 힘듭니다. 이런 종류의 조건을 주요 필터링 조건으로 설정하지 않을 것을 권장합니다. 인덱스의 주요 필터링 조건을 실행하면 문제가 크지 않습니다.
>- 모니터링에서 전체 테이블 스캔 양이 비교적 큰 것을 발견할 경우, 콘솔에서 매개 변수를 `log_queries_not_using_indexes`로 설정하고, 잠시 후 슬로우 로그 파일 분석을 다운로드합니다. 너무 오래 켜두면 슬로우 로그가 폭증할 수 있습니다.
>-비즈니스 런칭 전에 필요한 SQL 심사를 해야 하며, 상시 유지보수는 주기적으로 슬로우 쿼리 로그를 다운로드하여 맞춤형으로 최적화해야 합니다.
