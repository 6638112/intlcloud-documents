## 表定义的最佳实践
### 表结构定义准则
数据库设计在整个软件开发的起到的举足轻重的作用。本文将试图阐述数据库设计应对的原则和方案。

1.	字段名、表名不建议过长，推荐在32B内，不要包含特殊字符
2.	字段名、表名命名规范化，尽量表达实际含义，拒绝过度简写
3.	注意选择适合的数据类型，避免丢失精度
4.	主键和分表因子的选择具有高度离散化，便于负载均衡和扩缩容处理
5.	索引并不是越多越好，要根据查询有针对性的创建，避免和主键定义一致
6.	业务中IP地址字段推荐使用int类型
7.	时间类型尽量选择long类型，存储秒
8.	逻辑上相关的字段需要保留操作的原子性，建议合并到一张表里
9.	如果性能很关键，可以进行适当的冗余数据设计
10.	主键和分表因子的选择具有高度离散化，便于扩容处理
11.	主键的可读性强，不建议采用二进制类型，便于查阅跟进问题
12.	主键字段大小不建议太大，尽可能使用较短的主键，有利于加快查询速度
13.	字段大小按照需要使用，不建议定义时较大，但是实际使用较小的情况发生
14.	所有表和字段都需要添加注释

###	游戏业务相关的设计原则
1.	具有生成全局唯一的ID的需求，建议采用increase操作实现
2.	架构设计上避免DB过载，比如增加排队机制
3.	具有相关性的数据内容建议放在单个表里，规避出现数据不一致现象
4.	表的轻重需要分离，不建议所有的功能放在一个表中，独立的功能需要考虑独立的表
5.	表被频繁使用，且单表记录较大的，需要考虑设计简要表，避免直接获取原始数据表导致DB负载增加
6.	大厅聊天用共享内存即可，单局聊天实时push，不建议存储DB。 要支持离线私聊建议使用DB
7.	善于使用DB提供的数组数据结构，比如历史战绩、邮件、举报记录等。即能保证数据淘汰也能支持按照插入顺序的TopN操作
8.	排行榜设计时，如果能使用排序组件则直接使用排序组件；如果需要gameserver实现的，建议排行结果异步落地到DB
9.	游戏中比较边缘且比较耗时的操作，建议采用单独的进程处理，规避影响gameserver主逻辑
10.	游戏业务开放周期长，逻辑复杂，在开发过程中，容易出现逻辑数据结构的变更，从可扩展性和易维护的角度考虑，建议游戏数据表设计时，建议一些易变数据结构设计为数据表的blob来存储，序列化后再存储于数据库中。以避免因数据结构的变化而频繁修改数据库表

### TDR 表定义
1. 主键字段，需要较高的离散度，便于 gameserver 发送请求时分发到多个接入层节点。
2. 表定义时，建议索引键需主键不要完全一致，如果二者相同则浪费网络、磁盘资源。
3. 普通字段定义数组时需要增加 refer 属性（count 是定义大小，refer 是实际使用大小），便于 count 大小以后扩展，并且减少数据在网络上传输和磁盘上占用。
4. 普通字段推荐多采用一级字段，减少字段间嵌套，字段嵌套类型控制在3层以内。
5. 不推荐主键字段采用 binary 类型，不利于排查问题。
6. 单个表定义的索引最多8个，推荐2 - 3个，请按照实际情况设置索引。索引定义过多反而会降低整体性能。

### Protocol Buffers 表定义
1. 主键字段需要较高的离散度，便于 gameserver 发送请求时分发到多个接入层节点。
2. 支持定义嵌套的结构体类型`非主键`字段,嵌套深度太深将会影响数据访问性能。

###	不良设计举例
1.	设计与需求不符
修改量比较大，特别是项目临近上线阶段，修改成本更高。
2.	性能低下
含有大数据量的表之间的关联过多；没有合理的字段设计来用于查询而造成的SQL查询语句很复杂；对于大数据量的表没有采用有效的手段去处理；滥用视图等
3.	数据完整性丧失
含有主外键关系的表之间关联字段的设计方式不合理，造成更新与删除操作后程序容易出错或不完善；使用了已经删除或丢失掉的数据。
4.	可扩展性性太差
表设计的与业务绑定的太紧密、单一，造成表的可拓展性、可修改性太差，无法满足新需求的要求。
5.	非必要数据冗余量太大
没用的垃圾数据存储过多，不仅占用资源，还影响查询效率。
6.	不利于计算或统计
缺少必要的联系性或统计性字段或用于计算统计的字段分散于多个表中，造成计算统计的步骤繁琐，甚至无法计算统计。
7.	没有详尽的数据记录信息
缺少必要的字段，造成无法跟踪数据变化、用户操作，也无法进行数据分析。
8.	表之间的耦合性太大
多张表之间关联的过于紧密，造成一张表发生变化而影响到其他表。
9.	字段设计考虑不周
字段长度过短或字段类型过于明确，造成可发挥、可拓展的空间太小。