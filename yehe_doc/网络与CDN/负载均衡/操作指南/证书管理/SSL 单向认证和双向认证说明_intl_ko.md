SSL(Secure Sockets Layer, 보안 소켓 레이어)은 인터넷 통신을 위한 보안 및 데이터 무결성을 보장하도록 설계된 보안 프로토콜입니다. 본문은 SSL 단방향 인증과 양방향 인증을 소개합니다.
>?CLB 인스턴스에 대한 TCP SSL 리스너 또는 HTTPS 리스너를 생성할 때 SSL 구문 분석 방법으로 단방향 인증 또는 양방향 인증을 선택할 수 있습니다. 자세한 내용은 [Configuring TCP SSL Listener](https://intl.cloud.tencent.com/document/product/214/32519) 및 [Configuring HTTPS Listener](https://intl.cloud.tencent.com/document/product/214/32516)를 참고하십시오.

## SSL 단방향 인증과 양방향 인증의 차이점
- [SSL 단방향 인증 ](#dxrz)의 경우 인증서는 서버에만 필요하고 클라이언트에는 필요하지 않습니다. [SSL 양방향 인증 ](#sxrz)의 경우 서버와 클라이언트 모두에 인증서가 필요합니다.
- SSL 양방향 인증과 비교하여 단방향 인증은 서버에서 클라이언트 인증서 확인 및 암호화 스키마 협상을 포함하지 않습니다. 서버가 클라이언트에게 보내는 암호화 스키마는 암호화되지 않지만 SSL 인증의 보안은 손상되지 않습니다.
- Web 애플리케이션은 일반적으로 많은 수의 사용자를 가지고 있으며 SSL 단방향 인증을 사용할 수 있는 통신 레이어에서 사용자 신원 확인이 필요하지 않습니다. 그러나 금융 애플리케이션에 연결하는 클라이언트의 경우 신원 확인이 필요할 수 있으므로 SSL 양방향 인증을 사용해야 합니다.

<span id="dxrz"></span>
## SSL 단방향 인증
SSL 단방향 인증에서는 클라이언트 ID가 아닌 서버 ID만 확인하면 됩니다. SSL 단방향 인증 프로세스는 다음과 같습니다.
<img src="https://main.qcloudimg.com/raw/000d0a44b1bad4b015cfc81ad6e17441.png" width="70%">
1. 클라이언트는 지원되는 SSL 프로토콜 버전, 암호화 알고리즘, 생성된 랜덤 수 및 기타 정보와 함께 서버에 대한 HTTPS 연결 요청을 시작합니다.
2. 서버는 SSL 프로토콜 버전, 암호화 알고리즘, 생성된 랜덤 수, 서버 인증서(server.crt) 및 기타 정보를 클라이언트에 반환합니다.
3. 클라이언트는 아래 요인에 대한 인증서(server.crt)의 유효성을 확인하고 인증서에서 서버의 공개 키를 얻습니다.
  - 인증서 만료 여부입니다.
  - 인증서 해지 여부입니다.
  - 인증서 신뢰 가능 여부입니다.
  - 요청한 도메인 이름이 수신된 인증서의 도메인 이름과 동일한지 여부입니다.
4. 인증서가 검증된 후 클라이언트는 랜덤 수(통신을 위한 대칭 암호화 키로 사용되는 키 K)를 생성하고 서버 인증서에서 얻은 공개 키로 암호화한 다음 서버로 보냅니다.
5. 암호화된 정보를 수신한 후 서버는 개인 키(server.key)를 사용하여 대칭 암호화 키(키 K)를 얻기 위해 암호를 해독합니다.
대칭 암호화 키(키 K)는 정보 보안을 보장하기 위해 서버와 클라이언트에서 통신에 사용됩니다.

<span id="sxrz"></span>
## SSL 양방향 인증
SSL 양방향 인증에서는 서버 ID와 클라이언트 ID를 모두 확인해야 합니다. SSL 양방향 인증 과정은 다음과 같습니다.
<img src="https://main.qcloudimg.com/raw/93c4567863719926db8737aa345e008c.png" width="70%">
1. 클라이언트는 지원되는 SSL 프로토콜 버전, 암호화 알고리즘, 생성된 랜덤 수 및 기타 정보와 함께 서버에 대한 HTTPS 연결 요청을 시작합니다.
2. 서버는 SSL 프로토콜 버전, 암호화 알고리즘, 생성된 랜덤 수, 서버 인증서(server.crt) 및 기타 정보를 클라이언트에 반환합니다.
3. 클라이언트는 아래 요인에 대한 인증서(server.crt)의 유효성을 확인하고 인증서에서 서버의 공개 키를 얻습니다.
  - 인증서 만료 여부입니다.
  - 인증서 해지 여부입니다.
  - 인증서 신뢰 가능 여부입니다.
  - 요청한 도메인 이름이 수신된 인증서의 도메인 이름과 동일한지 여부입니다.
4. 서버는 클라이언트가 클라이언트 인증서(client.crt)를 보내도록 요구하고 클라이언트는 필요에 따라 보냅니다.
5. 서버는 클라이언트 인증서(client.crt)를 확인합니다. 확인된 후 서버는 루트 인증서(root.crt)를 사용하여 클라이언트 인증서를 해독하고 클라이언트의 공개 키를 얻습니다.
6. 클라이언트는 지원되는 대칭 암호화 스키마를 서버로 보냅니다.
7. 서버는 클라이언트가 보낸 스키마 중에서 암호화 수준이 가장 높은 암호화 스키마를 선택하고 클라이언트의 공개 키를 사용하여 암호화한 후 클라이언트에게 반환합니다.
4. 클라이언트는 개인 키(client.key)를 사용하여 암호화 스키마를 해독하고 랜덤 수(통신을 위한 대칭 암호화 키로 사용되는 키 K)를 생성하고 서버 인증서에서 얻은 공개 키로 암호화한 다음 서버로 보냅니다.
5. 암호화된 정보를 수신한 후 서버는 개인 키(server.key)를 사용하여 대칭 암호화 키(키 K)를 얻기 위해 암호를 해독합니다.
대칭 암호화 키(키 K)는 정보 보안을 보장하기 위해 서버와 클라이언트에서 통신에 사용됩니다.

## 관련 문서
[Certificate Requirements and Certificate Format Conversion](https://intl.cloud.tencent.com/document/product/214/6155)
